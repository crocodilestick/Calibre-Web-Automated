<!-- Library Stats Content -->

<style>
    .filter-row {
        display: flex;
        gap: 15px;
        justify-content: flex-start;
        align-items: center;
        margin-bottom: 30px;
        flex-wrap: wrap;
        background: #2a3441;
        border: 1px solid #3a4451;
        border-radius: 8px;
        padding: 15px 20px;
    }
    
    .time-period-select {
        background: #1a2332;
        color: #ddd;
        border: 1px solid #3a4451;
        border-radius: 6px;
        padding: 8px 15px;
        font-size: 0.95em;
        cursor: pointer;
        transition: border-color 0.3s;
    }
    
    .time-period-select:focus {
        outline: none;
        border-color: #ff9800;
    }
    
    #library-custom-date-range input[type="date"] {
        background: #1a2332;
        color: #ddd;
        border: 1px solid #3a4451;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 0.95em;
    }
    
    #library-custom-date-range input[type="date"]:focus {
        outline: none;
        border-color: #ff9800;
    }
    
    #library-custom-date-range span {
        color: #999;
        font-size: 0.9em;
    }

    .demo-toggle {
        background: linear-gradient(135deg, #ff9800 0%, #ff6f00 100%);
        color: white;
        border: none;
        padding: 15px 40px;
        border-radius: 6px;
        font-size: 1.1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
    }
    
    .demo-toggle:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 152, 0, 0.5);
        background: linear-gradient(135deg, #ffa726 0%, #ff8a00 100%);
    }
    
    .demo-toggle.active {
        background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
    }
    
    .demo-badge {
        display: inline-block;
        background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
        color: white;
        padding: 5px 15px;
        border-radius: 4px;
        font-size: 0.85em;
        margin-left: 10px;
        font-weight: 600;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    /* Loading Spinner */
    .chart-loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50px;
        height: 50px;
        border: 4px solid #3a4451;
        border-top-color: #ff9800;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        z-index: 10;
    }
    
    .chart-loading-overlay {
        position: relative;
        min-height: 300px;
    }
    
    @keyframes spin {
        0% { transform: translate(-50%, -50%) rotate(0deg); }
        100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    .library-stats-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }
    
    /* Force 2x2 grid for medium viewports */
    @media (min-width: 768px) and (max-width: 1346px) {
        .library-stats-container {
            grid-template-columns: repeat(2, 1fr);
        }
    }
    
    /* 4 columns for large viewports */
    @media (min-width: 1347px) {
        .library-stats-container {
            grid-template-columns: repeat(4, 1fr);
        }
    }
    
    .library-stat-card {
        background: linear-gradient(135deg, #2a3441 0%, #1a2332 100%);
        border-radius: 12px;
        padding: 25px;
        border: 1px solid #3a4451;
        text-align: center;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .library-stat-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 20px rgba(255, 152, 0, 0.2);
    }
    
    .library-stat-icon {
        font-size: 2.5em;
        margin-bottom: 10px;
    }
    
    .library-stat-value {
        font-size: 2.5em;
        font-weight: bold;
        color: #ff9800;
        margin: 10px 0;
    }
    
    .library-stat-label {
        font-size: 1.1em;
        color: #bbb;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    .trend-indicator {
        display: inline-block;
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 0.9em;
        font-weight: bold;
        margin-top: 10px;
    }
    
    .trend-up {
        background: rgba(76, 175, 80, 0.2);
        color: #4caf50;
    }
    
    .trend-down {
        background: rgba(244, 67, 54, 0.2);
        color: #f44336;
    }
    
    .trend-neutral {
        background: rgba(255, 152, 0, 0.2);
        color: #ff9800;
    }
    
    .fixed-book-item {
        background: #1a2332;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 12px;
        border-left: 3px solid #ff9800;
        transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .fixed-book-item:hover {
        transform: translateX(5px);
        box-shadow: 0 4px 15px rgba(255, 152, 0, 0.2);
    }
    
    .fixed-book-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .fixed-book-name {
        font-weight: 600;
        color: #ddd;
        font-size: 1.05em;
    }
    
    .fixed-book-badge {
        background: linear-gradient(135deg, #ff9800 0%, #ff6f00 100%);
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 0.85em;
        font-weight: 600;
    }
    
    .fixed-book-details {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }
    
    .fixed-book-meta {
        color: #999;
        font-size: 0.9em;
    }
</style>

<div class="stats-hero">
    <h1>üìö Library Statistics</h1>
    <p>Comprehensive insights into your Calibre library collection</p>
</div>

<!-- Time Period Filter -->
<div class="filter-row">
    <select id="library-time-period" class="time-period-select" onchange="changeLibraryTimePeriod()">
        <option value="7" {{ 'selected' if request.args.get('days') == '7' else '' }}>Last 7 Days</option>
        <option value="30" {{ 'selected' if request.args.get('days') == '30' or not request.args.get('days') else '' }}>Last 30 Days</option>
        <option value="90" {{ 'selected' if request.args.get('days') == '90' else '' }}>Last 90 Days</option>
        <option value="180" {{ 'selected' if request.args.get('days') == '180' else '' }}>Last 6 Months</option>
        <option value="365" {{ 'selected' if request.args.get('days') == '365' else '' }}>Last Year</option>
        <option value="all" {{ 'selected' if request.args.get('days') == 'all' else '' }}>All Time</option>
        <option value="custom" {{ 'selected' if request.args.get('start_date') else '' }}>Custom Range</option>
    </select>
    
    <div id="library-custom-date-range" style="display: {{ 'flex' if request.args.get('start_date') else 'none' }}; gap: 10px; align-items: center;">
        <input type="date" id="library-start-date" value="{{ request.args.get('start_date', '') }}" />
        <span>to</span>
        <input type="date" id="library-end-date" value="{{ request.args.get('end_date', '') }}" />
        <button onclick="applyLibraryDateRange()" class="btn btn-primary btn-sm">Apply</button>
    </div>

    <button onclick="window.location.href='/cwa-stats-show?tab=library'" class="demo-toggle" style="margin-left: 10px;">
        üîÑ Reset
    </button>
    
    <button onclick="exportLibraryCSV()" class="demo-toggle" style="margin-left: 10px; background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%); box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);">
        üì• Export CSV
    </button>
    
    <button onclick="toggleLibraryDemoMode()" class="demo-toggle" id="library-demo-button" style="margin-left: auto;">
        üé® Show Demo Data
    </button>
    <span class="demo-badge" id="library-demo-badge" style="display: none;">DEMO MODE</span>
    
</div>

<!-- Library Stats Cards -->
<div class="library-stats-container">
    <div class="library-stat-card">
        <div class="library-stat-icon">üìñ</div>
        <div class="library-stat-label">Total Books</div>
        <div class="library-stat-value" id="total-books">{{ cwa_stats.total_books }}</div>
    </div>
    <div class="library-stat-card">
        <div class="library-stat-icon">‚ûï</div>
        <div class="library-stat-label">Added Books</div>
        {% if books_added_stats.total == cwa_stats.total_books %}
        <div class="library-stat-value" id="books-added">N/A</div>
        <small style="color: #999; margin-top: 10px; display: block;">All time view</small>
        {% else %}
        <div class="library-stat-value" id="books-added">{{ books_added_stats.total }}</div>
        <div class="trend-indicator {{ 'trend-up' if books_added_stats.trend > 0 else 'trend-down' if books_added_stats.trend < 0 else 'trend-neutral' }}" id="books-added-trend">
            {{ '‚Üë' if books_added_stats.trend > 0 else '‚Üì' if books_added_stats.trend < 0 else '‚Üí' }} 
            {{ books_added_stats.trend|abs }}%
        </div>
        {% endif %}
    </div>
    <div class="library-stat-card">
        <div class="library-stat-icon">üîÑ</div>
        <div class="library-stat-label">Conversions</div>
        <div class="library-stat-value" id="conversion-count">{{ conversion_stats.total }}</div>
        <div class="trend-indicator {{ 'trend-up' if conversion_stats.trend > 0 else 'trend-down' if conversion_stats.trend < 0 else 'trend-neutral' }}" id="conversion-trend">
            {{ '‚Üë' if conversion_stats.trend > 0 else '‚Üì' if conversion_stats.trend < 0 else '‚Üí' }} 
            {{ conversion_stats.trend|abs }}%
        </div>
    </div>
    <div class="library-stat-card">
        <div class="library-stat-icon">üì¶</div>
        <div class="library-stat-label">Total Formats</div>
        <div class="library-stat-value" id="format-count">{{ library_formats|length }}</div>
    </div>
</div>

<!-- Library Growth Timeline (Hero Chart) -->
<div class="chart-container">
    <div class="chart-title">üìà Library Growth Over Time</div>
    <div id="growth-chart" style="width: 100%; height: 450px;"></div>
</div>

<!-- Third Row: Series Completion & Publication Years -->
<div class="row cwa-stats-row">
    <div class="col-md-6">
        <div class="chart-container">
            <div class="chart-title">üìö Largest Series</div>
            <div id="series-completion-chart" style="width: 100%; height: 400px;"></div>
        </div>
    </div>
    <div class="col-md-6">
        <div class="chart-container">
            <div class="chart-title">üìÖ Publication Year Distribution</div>
            <div id="publication-year-chart" style="width: 100%; height: 400px;"></div>
        </div>
    </div>
</div>

<!-- Fifth Row: Sprint 6 - Rating & Enforcement -->
<div class="row cwa-stats-row">
    <div class="col-md-6">
        <div class="chart-container" style="min-height: 520px;">
            <div class="chart-title">‚≠ê Rating Statistics</div>
            <div id="rating-stats-chart" style="width: 100%; height: 450px;"></div>
        </div>
    </div>
    <div class="col-md-6">
        <div class="chart-container" style="min-height: 520px;">
            <div class="chart-title">üõ°Ô∏è Top Enforced Books</div>
            <div id="top-enforced-chart" style="width: 100%; height: 450px;"></div>
        </div>
    </div>
</div>

<!-- Sixth Row: Sprint 6 - Import Flows -->
<div class="row cwa-stats-row">
    <div class="col-md-12">
        <div class="chart-container" style="min-height: 520px;">
            <div class="chart-title">üîÑ Import Source Flows</div>
            <div id="import-sankey-chart" style="width: 100%; height: 450px;"></div>
        </div>
    </div>
</div>

<!-- Second Row: Format Distribution -->
<div class="row cwa-stats-row">
    <div class="col-md-12">
        <div class="chart-container">
            <div class="chart-title">üìä Format Distribution</div>
            <div id="library-formats-chart" style="width: 100%; height: 400px;"></div>
        </div>
    </div>
</div>

<!-- Fourth Row: Most Fixed Books -->
<div class="row cwa-stats-row">
    <div class="col-md-12">
        <div class="chart-container">
            <div class="chart-title">üîß Most Fixed Books</div>
            <div id="most-fixed-books-list" style="padding: 20px;">
                {% if most_fixed_books %}
                    {% for filename, fix_count, total_fixes, last_fixed, file_path in most_fixed_books %}
                    <div class="fixed-book-item">
                        <div class="fixed-book-header">
                            <span class="fixed-book-name">üìñ {{ filename }}</span>
                            <span class="fixed-book-badge">{{ fix_count }} fix{{ 'es' if fix_count > 1 else '' }}</span>
                        </div>
                        <div class="fixed-book-details">
                            <span class="fixed-book-meta">üïí Last fixed: {{ last_fixed }}</span>
                            <span class="fixed-book-meta">üìÅ {{ file_path }}</span>
                        </div>
                    </div>
                    {% endfor %}
                {% else %}
                    <p style="text-align: center; color: #999; padding: 20px;">No EPUB fixes recorded</p>
                {% endif %}
            </div>
        </div>
    </div>
</div>


<script>
// Data from backend
const realLibraryData = {
    growth: {{ library_growth | tojson }},
    formats: {{ library_formats | tojson }},
    conversionStats: {{ conversion_stats | tojson }},
    booksAddedStats: {{ books_added_stats | tojson }},
    totalBooks: {{ cwa_stats.total_books }},
    seriesCompletion: {{ series_completion | tojson }},
    publicationYears: {{ publication_years | tojson }},
    mostFixedBooks: {{ most_fixed_books | tojson }},
    ratingStats: {{ rating_statistics | tojson }},
    topEnforced: {{ top_enforced_books | tojson }},
    importFlows: {{ import_source_flows | tojson }}
};

// State management
let libraryDemoMode = false;
let currentLibraryData = realLibraryData;

// Initialize charts
let growthChart, libraryFormatsChart, seriesChart, publicationYearChart;
let ratingStatsChart, topEnforcedChart, importSankeyChart;

function initLibraryCharts() {
    growthChart = echarts.init(document.getElementById('growth-chart'));
    libraryFormatsChart = echarts.init(document.getElementById('library-formats-chart'));
    seriesChart = echarts.init(document.getElementById('series-completion-chart'));
    publicationYearChart = echarts.init(document.getElementById('publication-year-chart'));
    ratingStatsChart = echarts.init(document.getElementById('rating-stats-chart'));
    topEnforcedChart = echarts.init(document.getElementById('top-enforced-chart'));
    importSankeyChart = echarts.init(document.getElementById('import-sankey-chart'));
    
    updateAllLibraryCharts();
    
    // Responsive resize
    window.addEventListener('resize', () => {
        growthChart.resize();
        libraryFormatsChart.resize();
        seriesChart.resize();
        publicationYearChart.resize();
        ratingStatsChart.resize();
        topEnforcedChart.resize();
        importSankeyChart.resize();
    });
}

function updateAllLibraryCharts() {
    updateLibraryStatCards();
    updateLibraryGrowthChart();
    updateLibraryFormatsChart();
    updateSeriesCompletionChart();
    updatePublicationYearChart();
    updateRatingStatsChart();
    updateTopEnforcedChart();
    updateImportSankeyChart();
}

function updateLibraryStatCards() {
    const totalBooks = currentLibraryData.totalBooks;
    const booksAdded = currentLibraryData.booksAddedStats.total;
    
    document.getElementById('total-books').textContent = totalBooks;
    document.getElementById('conversion-count').textContent = currentLibraryData.conversionStats.total;
    document.getElementById('format-count').textContent = currentLibraryData.formats.length;
    
    // Check if books added equals total books (all time view)
    const booksAddedEl = document.getElementById('books-added');
    const booksAddedTrendEl = document.getElementById('books-added-trend');
    
    if (booksAdded === totalBooks) {
        booksAddedEl.textContent = 'N/A';
        if (booksAddedTrendEl) {
            booksAddedTrendEl.style.display = 'none';
        }
    } else {
        booksAddedEl.textContent = booksAdded;
        if (booksAddedTrendEl) {
            booksAddedTrendEl.style.display = 'inline-block';
            const booksAddedTrend = currentLibraryData.booksAddedStats.trend;
            booksAddedTrendEl.className = 'trend-indicator ' + (booksAddedTrend > 0 ? 'trend-up' : booksAddedTrend < 0 ? 'trend-down' : 'trend-neutral');
            booksAddedTrendEl.innerHTML = (booksAddedTrend > 0 ? '‚Üë' : booksAddedTrend < 0 ? '‚Üì' : '‚Üí') + ' ' + Math.abs(booksAddedTrend) + '%';
        }
    }
    
    // Update conversion trend indicator
    const conversionTrend = currentLibraryData.conversionStats.trend;
    const conversionTrendEl = document.getElementById('conversion-trend');
    conversionTrendEl.className = 'trend-indicator ' + (conversionTrend > 0 ? 'trend-up' : conversionTrend < 0 ? 'trend-down' : 'trend-neutral');
    conversionTrendEl.innerHTML = (conversionTrend > 0 ? '‚Üë' : conversionTrend < 0 ? '‚Üì' : '‚Üí') + ' ' + Math.abs(conversionTrend) + '%';
}

function updateLibraryGrowthChart() {
    const data = currentLibraryData.growth || [];
    
    if (data.length === 0) {
        growthChart.setOption({
            title: {
                text: 'No growth data available',
                left: 'center',
                top: 'center',
                textStyle: {
                    color: '#999',
                    fontSize: 14
                }
            }
        }, true);
        return;
    }
    
    // Calculate cumulative totals
    let cumulative = 0;
    const cumulativeData = data.map(([date, count]) => {
        cumulative += count;
        return [date, cumulative];
    });
    
    const option = {
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'cross'
            },
            formatter: (params) => {
                const date = params[0].axisValue;
                const added = params[0].value;
                const total = params[1] ? params[1].value : cumulative;
                return `${date}<br/>
                        üì• Added: ${added}<br/>
                        üìö Total: ${total}`;
            }
        },
        legend: {
            data: ['Books Added', 'Total Library Size'],
            textStyle: {
                color: '#fff'
            },
            top: '5%'
        },
        grid: {
            left: '3%',
            right: '4%',
            bottom: '15%',
            top: '15%',
            containLabel: true
        },
        xAxis: {
            type: 'category',
            boundaryGap: true,
            data: data.map(d => d[0]),
            axisLabel: {
                color: '#fff',
                rotate: 45
            },
            axisLine: {
                lineStyle: { color: '#3a4451' }
            }
        },
        yAxis: [
            {
                type: 'value',
                name: 'Books Added',
                nameTextStyle: {
                    color: '#fff'
                },
                axisLabel: {
                    color: '#fff'
                },
                axisLine: {
                    lineStyle: { color: '#3a4451' }
                },
                splitLine: {
                    lineStyle: { color: '#3a4451' }
                }
            },
            {
                type: 'value',
                name: 'Total Books',
                nameTextStyle: {
                    color: '#fff'
                },
                axisLabel: {
                    color: '#fff'
                },
                axisLine: {
                    lineStyle: { color: '#3a4451' }
                },
                splitLine: {
                    show: false
                }
            }
        ],
        series: [
            {
                name: 'Books Added',
                type: 'bar',
                data: data.map(d => d[1]),
                itemStyle: {
                    color: new echarts.graphic.LinearGradient(0, 1, 0, 0, [
                        { offset: 0, color: '#ff6f00' },
                        { offset: 1, color: '#ff9800' }
                    ]),
                    borderRadius: [6, 6, 0, 0]
                }
            },
            {
                name: 'Total Library Size',
                type: 'line',
                yAxisIndex: 1,
                data: cumulativeData.map(d => d[1]),
                smooth: true,
                lineStyle: {
                    color: '#2196f3',
                    width: 3
                },
                areaStyle: {
                    color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                        { offset: 0, color: 'rgba(33, 150, 243, 0.3)' },
                        { offset: 1, color: 'rgba(33, 150, 243, 0.05)' }
                    ])
                },
                itemStyle: {
                    color: '#2196f3'
                }
            }
        ]
    };
    
    growthChart.setOption(option, true);
}

function updateLibraryFormatsChart() {
    const data = currentLibraryData.formats || [];
    
    if (data.length === 0) {
        libraryFormatsChart.setOption({
            title: {
                text: 'No format data available',
                left: 'center',
                top: 'center',
                textStyle: {
                    color: '#999',
                    fontSize: 14
                }
            }
        }, true);
        return;
    }
    
    const option = {
        tooltip: {
            trigger: 'item',
            backgroundColor: 'rgba(0,0,0,0.8)',
            textStyle: { color: '#fff' },
            formatter: '{b}: {c} books ({d}%)'
        },
        legend: {
            type: 'scroll',
            orient: 'horizontal',
            bottom: '5%',
            textStyle: { color: '#fff' }
        },
        series: [{
            type: 'pie',
            radius: ['40%', '70%'],
            center: ['50%', '40%'],
            data: data.map(([format, count]) => ({
                name: format,
                value: count
            })),
            emphasis: {
                itemStyle: {
                    shadowBlur: 10,
                    shadowOffsetX: 0,
                    shadowColor: 'rgba(255, 152, 0, 0.5)'
                }
            },
            itemStyle: {
                borderRadius: 8,
                borderColor: '#1a2332',
                borderWidth: 2
            },
            label: {
                color: '#fff',
                formatter: '{b}: {d}%'
            }
        }]
    };
    
    libraryFormatsChart.setOption(option, true);
}

function updateSeriesCompletionChart() {
    const data = currentLibraryData.seriesCompletion || [];
    
    if (data.length === 0) {
        seriesChart.setOption({
            title: {
                text: 'No series data available',
                left: 'center',
                top: 'center',
                textStyle: {
                    color: '#999',
                    fontSize: 14
                }
            }
        }, true);
        return;
    }
    
    const option = {
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'shadow'
            },
            formatter: (params) => {
                const series = params[0].name;
                const bookCount = params[0].value;
                const highestIndex = data[params[0].dataIndex][2];
                return `<strong>${series}</strong><br/>
                        Books: ${bookCount}<br/>
                        Highest Index: ${highestIndex}`;
            }
        },
        grid: {
            left: '3%',
            right: '4%',
            bottom: '3%',
            top: '5%',
            containLabel: true
        },
        xAxis: {
            type: 'value',
            name: 'Number of Books',
            nameLocation: 'middle',
            nameGap: 30,
            minInterval: 1,
            axisLabel: {
                color: '#fff'
            },
            axisLine: {
                lineStyle: { color: '#3a4451' }
            },
            splitLine: {
                lineStyle: { color: '#3a4451' }
            }
        },
        yAxis: {
            type: 'category',
            data: data.map(d => d[0]),
            axisLabel: {
                color: '#fff',
                overflow: 'truncate',
                width: 150
            },
            axisLine: {
                lineStyle: { color: '#3a4451' }
            }
        },
        series: [
            {
                name: 'Books',
                type: 'bar',
                data: data.map(d => d[1]),
                itemStyle: {
                    color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                        { offset: 0, color: '#5470c6' },
                        { offset: 1, color: '#91cc75' }
                    ]),
                    borderRadius: [0, 4, 4, 0]
                },
                label: {
                    show: true,
                    position: 'right',
                    formatter: '{c}',
                    color: '#fff'
                }
            }
        ]
    };
    
    seriesChart.setOption(option, true);
}

function updatePublicationYearChart() {
    const data = currentLibraryData.publicationYears || [];
    
    if (data.length === 0) {
        publicationYearChart.setOption({
            title: {
                text: 'No publication year data available',
                left: 'center',
                top: 'center',
                textStyle: {
                    color: '#999',
                    fontSize: 14
                }
            }
        }, true);
        return;
    }
    
    const option = {
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'shadow'
            },
            formatter: (params) => {
                return `${params[0].name}: ${params[0].value} books`;
            }
        },
        grid: {
            left: '3%',
            right: '4%',
            bottom: '15%',
            top: '10%',
            containLabel: true
        },
        xAxis: {
            type: 'category',
            data: data.map(d => d[0]),
            axisLabel: {
                color: '#fff',
                rotate: 45
            },
            axisLine: {
                lineStyle: { color: '#3a4451' }
            }
        },
        yAxis: {
            type: 'value',
            name: 'Books',
            nameTextStyle: {
                color: '#fff'
            },
            axisLabel: {
                color: '#fff'
            },
            axisLine: {
                lineStyle: { color: '#3a4451' }
            },
            splitLine: {
                lineStyle: { color: '#3a4451' }
            }
        },
        series: [{
            type: 'bar',
            data: data.map(d => d[1]),
            itemStyle: {
                color: new echarts.graphic.LinearGradient(0, 1, 0, 0, [
                    { offset: 0, color: '#2196f3' },
                    { offset: 1, color: '#64b5f6' }
                ]),
                borderRadius: [6, 6, 0, 0]
            }
        }]
    };
    
    publicationYearChart.setOption(option, true);
}

function updateRatingStatsChart() {
    const data = currentLibraryData.ratingStats || {};
    
    if (!data.rating_distribution || data.rating_distribution.length === 0) {
        ratingStatsChart.setOption({
            title: {
                text: 'No rating data available',
                left: 'center',
                top: 'center',
                textStyle: { color: '#999', fontSize: 14 }
            }
        }, true);
        return;
    }
    
    const avgRating = data.average_rating || 0;
    const trend = data.trend || 0;
    const unratedPct = data.unrated_percentage || 0;
    
    // Create star display
    const fullStars = Math.floor(avgRating);
    const hasHalfStar = (avgRating % 1) >= 0.5;
    let starDisplay = '‚òÖ'.repeat(fullStars);
    if (hasHalfStar) starDisplay += '‚Ø®';
    starDisplay += '‚òÜ'.repeat(5 - fullStars - (hasHalfStar ? 1 : 0));
    
    const trendColor = trend > 0 ? '#4caf50' : trend < 0 ? '#f44336' : '#ff9800';
    const trendIcon = trend > 0 ? '‚Üë' : trend < 0 ? '‚Üì' : '‚Üí';
    
    const option = {
        title: [{
            text: `${starDisplay} ${avgRating.toFixed(1)}`,
            left: 'center',
            top: '5%',
            textStyle: {
                fontSize: 24,
                color: '#ff9800',
                fontWeight: 'bold'
            }
        }, {
            text: `${trendIcon} ${Math.abs(trend)}% ${trend !== 0 ? 'vs prev period' : ''}`,
            left: 'center',
            top: '15%',
            textStyle: {
                fontSize: 14,
                color: trendColor,
                fontWeight: 'normal'
            }
        }, {
            text: `${unratedPct}% Unrated`,
            left: 'center',
            top: '22%',
            textStyle: {
                fontSize: 12,
                color: '#999'
            }
        }],
        grid: {
            left: '10%',
            right: '10%',
            bottom: '5%',
            top: '30%',
            containLabel: true
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: { type: 'shadow' },
            formatter: (params) => {
                const stars = params[0].name;
                const count = params[0].value;
                return `${stars} Star${stars > 1 ? 's' : ''}: ${count} books`;
            }
        },
        xAxis: {
            type: 'value',
            name: 'Books',
            axisLabel: { color: '#fff' },
            axisLine: { lineStyle: { color: '#3a4451' } },
            splitLine: { lineStyle: { color: '#3a4451' } }
        },
        yAxis: {
            type: 'category',
            data: data.rating_distribution.map(d => `${d[0]} ‚òÖ`),
            axisLabel: { color: '#fff', fontSize: 14 },
            axisLine: { lineStyle: { color: '#3a4451' } }
        },
        series: [{
            type: 'bar',
            data: data.rating_distribution.map(d => d[1]),
            itemStyle: {
                color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                    { offset: 0, color: '#ff9800' },
                    { offset: 1, color: '#ffc107' }
                ]),
                borderRadius: [0, 4, 4, 0]
            },
            label: {
                show: true,
                position: 'right',
                formatter: '{c}',
                color: '#fff'
            }
        }]
    };
    
    ratingStatsChart.setOption(option, true);
}

function updateTopEnforcedChart() {
    const data = currentLibraryData.topEnforced || [];
    
    if (data.length === 0) {
        topEnforcedChart.setOption({
            title: {
                text: 'No enforcement data available',
                left: 'center',
                top: 'center',
                textStyle: { color: '#999', fontSize: 14 }
            }
        }, true);
        return;
    }
    
    const option = {
        tooltip: {
            trigger: 'axis',
            axisPointer: { type: 'shadow' },
            formatter: (params) => {
                const title = params[0].name;
                const count = params[0].value;
                const lastEnforced = data[params[0].dataIndex][3];
                return `<strong>${title}</strong><br/>
                        Enforcements: ${count}<br/>
                        Last: ${lastEnforced}`;
            }
        },
        grid: {
            left: '5%',
            right: '5%',
            bottom: '5%',
            top: '5%',
            containLabel: true
        },
        xAxis: {
            type: 'value',
            name: 'Enforcements',
            axisLabel: { color: '#fff' },
            axisLine: { lineStyle: { color: '#3a4451' } },
            splitLine: { lineStyle: { color: '#3a4451' } }
        },
        yAxis: {
            type: 'category',
            data: data.map(d => d[1]),  // Book titles
            axisLabel: {
                color: '#fff',
                overflow: 'truncate',
                width: 120,
                fontSize: 11
            },
            axisLine: { lineStyle: { color: '#3a4451' } }
        },
        series: [{
            type: 'bar',
            data: data.map(d => d[2]),  // Enforcement counts
            itemStyle: {
                color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                    { offset: 0, color: '#9c27b0' },
                    { offset: 1, color: '#ba68c8' }
                ]),
                borderRadius: [0, 4, 4, 0]
            },
            label: {
                show: true,
                position: 'right',
                formatter: '{c}',
                color: '#fff'
            }
        }]
    };
    
    topEnforcedChart.setOption(option, true);
}

function updateImportSankeyChart() {
    const data = currentLibraryData.importFlows || [];
    
    if (data.length === 0) {
        importSankeyChart.setOption({
            title: {
                text: 'No conversion data available',
                left: 'center',
                top: 'center',
                textStyle: { color: '#999', fontSize: 14 }
            }
        }, true);
        return;
    }
    
    // Extract unique nodes (formats)
    const nodeSet = new Set();
    data.forEach(([source, target, value]) => {
        nodeSet.add(source);
        nodeSet.add(target);
    });
    
    const nodes = Array.from(nodeSet).map(name => ({ name }));
    const links = data.map(([source, target, value]) => ({
        source,
        target,
        value
    }));
    
    const option = {
        tooltip: {
            trigger: 'item',
            triggerOn: 'mousemove',
            formatter: (params) => {
                if (params.dataType === 'edge') {
                    return `${params.data.source} ‚Üí ${params.data.target}<br/>Conversions: ${params.data.value}`;
                }
                return params.name;
            }
        },
        series: [{
            type: 'sankey',
            layout: 'none',
            emphasis: {
                focus: 'adjacency'
            },
            data: nodes,
            links: links,
            lineStyle: {
                color: 'gradient',
                curveness: 0.5
            },
            itemStyle: {
                color: '#4caf50',
                borderColor: '#1a2332',
                borderWidth: 2
            },
            label: {
                color: '#fff',
                fontSize: 12,
                fontWeight: 'bold'
            }
        }]
    };
    
    importSankeyChart.setOption(option, true);
}

// Time period filter functions
function changeLibraryTimePeriod() {
    const select = document.getElementById('library-time-period');
    const customRange = document.getElementById('library-custom-date-range');
    
    if (select.value === 'custom') {
        customRange.style.display = 'flex';
    } else {
        customRange.style.display = 'none';
        window.location.href = `/cwa-stats-show?tab=library&days=${select.value}`;
    }
}

function applyLibraryDateRange() {
    const startDate = document.getElementById('library-start-date').value;
    const endDate = document.getElementById('library-end-date').value;
    
    if (!startDate || !endDate) {
        alert('Please select both start and end dates');
        return;
    }
    
    window.location.href = `/cwa-stats-show?tab=library&start_date=${startDate}&end_date=${endDate}`;
}

// Demo data generator
function generateLibraryDemoData() {
    // Read URL parameters for date range
    const urlParams = new URLSearchParams(window.location.search);
    const days = parseInt(urlParams.get('days')) || 30;
    const startDate = urlParams.get('start_date');
    const endDate = urlParams.get('end_date');
    
    let demoGrowth = [];
    let totalDays = days;
    
    // Calculate number of days for demo data
    if (startDate && endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);
        totalDays = Math.floor((end - start) / (1000 * 60 * 60 * 24));
    }
    
    // Generate demo growth data
    const today = new Date();
    let cumulative = Math.floor(Math.random() * 500) + 100; // Starting library size
    
    for (let i = totalDays; i >= 0; i--) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        // Random books added per day (0-15, weighted towards lower numbers)
        const booksAdded = Math.floor(Math.random() * Math.random() * 16);
        cumulative += booksAdded;
        demoGrowth.push([dateStr, booksAdded]);
    }
    
    // Generate demo format distribution
    const demoFormats = [
        ['EPUB', Math.floor(Math.random() * 300) + 200],
        ['PDF', Math.floor(Math.random() * 250) + 150],
        ['MOBI', Math.floor(Math.random() * 150) + 80],
        ['AZW3', Math.floor(Math.random() * 100) + 50],
        ['CBR', Math.floor(Math.random() * 80) + 30],
        ['CBZ', Math.floor(Math.random() * 60) + 20],
        ['TXT', Math.floor(Math.random() * 40) + 10],
        ['DJVU', Math.floor(Math.random() * 30) + 5]
    ];
    
    // Generate demo conversion stats
    const totalConversions = Math.floor(Math.random() * 150) + 50;
    const conversionTrend = (Math.random() * 60) - 20; // -20% to +40%
    
    // Generate demo books added stats
    const totalBooksAdded = demoGrowth.reduce((sum, [date, count]) => sum + count, 0);
    const booksAddedTrend = (Math.random() * 50) - 15; // -15% to +35%
    
    // Generate demo series completion (now largest series)
    const seriesNames = ['Harry Potter', 'The Expanse', 'Foundation', 'Discworld', 'Wheel of Time', 
                        'A Song of Ice and Fire', 'The Witcher', 'Mistborn', 'The Stormlight Archive', 'Dune'];
    const demoSeries = seriesNames.map(name => {
        const bookCount = Math.floor(Math.random() * 15) + 3; // 3-17 books
        const highestIndex = Math.floor(Math.random() * 3) + bookCount; // May have gaps
        return [name, bookCount, highestIndex];
    }).sort((a, b) => b[1] - a[1]); // Sort by book count descending
    
    // Generate demo publication years
    const currentYear = new Date().getFullYear();
    const demoYears = [];
    for (let year = currentYear - 30; year <= currentYear; year++) {
        const count = Math.floor(Math.random() * 50) + 5;
        demoYears.push([year, count]);
    }
    
    // Generate demo most fixed books
    const bookTitles = ['The Great Gatsby.epub', 'Pride and Prejudice.epub', '1984.epub', 
                       'To Kill a Mockingbird.epub', 'The Hobbit.epub'];
    const demoFixedBooks = bookTitles.map(title => {
        const fixCount = Math.floor(Math.random() * 5) + 1;
        return [title, fixCount, `${fixCount}`, '2024-12-28 14:30:00', '/calibre-library/Author/Book'];
    });
    
    // Generate demo rating statistics
    const ratingDist = [
        [5, Math.floor(Math.random() * 80) + 50],
        [4, Math.floor(Math.random() * 150) + 100],
        [3, Math.floor(Math.random() * 100) + 80],
        [2, Math.floor(Math.random() * 40) + 20],
        [1, Math.floor(Math.random() * 20) + 5]
    ];
    const totalRated = ratingDist.reduce((sum, [_, count]) => sum + count, 0);
    const weightedSum = ratingDist.reduce((sum, [stars, count]) => sum + (stars * count), 0);
    const avgRating = weightedSum / totalRated;
    const demoRatingStats = {
        average_rating: Math.round(avgRating * 100) / 100,
        rating_distribution: ratingDist,
        unrated_percentage: Math.round((Math.random() * 30 + 10) * 10) / 10,
        trend: Math.round((Math.random() * 10 - 5) * 10) / 10,
        total_books: cumulative,
        rated_books: totalRated
    };
    
    // Generate demo top enforced books
    const enforcedBookTitles = [
        'The Fellowship of the Ring', 'A Game of Thrones', 'The Name of the Wind',
        'Neuromancer', 'Snow Crash', 'The Hitchhiker\'s Guide', 'Ender\'s Game',
        'Do Androids Dream of Electric Sheep', 'Foundation', 'Dune'
    ];
    const demoTopEnforced = enforcedBookTitles.map((title, idx) => {
        const count = Math.floor(Math.random() * 15) + (10 - idx); // Higher for top books
        return [idx + 1, title, count, '2024-12-28 10:30:00'];
    }).sort((a, b) => b[2] - a[2]).slice(0, 10);
    
    // Generate demo import flows
    const sourceFormats = ['MOBI', 'AZW3', 'PDF', 'CBR', 'CBZ', 'FB2', 'LIT', 'RTF'];
    const targetFormats = ['EPUB', 'PDF', 'MOBI'];
    const demoImportFlows = [];
    for (let i = 0; i < Math.min(15, sourceFormats.length * 2); i++) {
        const source = sourceFormats[Math.floor(Math.random() * sourceFormats.length)];
        const target = targetFormats[Math.floor(Math.random() * targetFormats.length)];
        if (source !== target) {
            const value = Math.floor(Math.random() * 100) + 10;
            demoImportFlows.push([source, target, value]);
        }
    }
    
    return {
        growth: demoGrowth,
        formats: demoFormats,
        conversionStats: {
            total: totalConversions,
            successful: totalConversions,
            failed: 0,
            success_rate: 100.0,
            trend: Math.round(conversionTrend * 10) / 10
        },
        booksAddedStats: {
            total: totalBooksAdded,
            trend: Math.round(booksAddedTrend * 10) / 10
        },
        totalBooks: cumulative,
        seriesCompletion: demoSeries,
        publicationYears: demoYears,
        mostFixedBooks: demoFixedBooks,
        ratingStats: demoRatingStats,
        topEnforced: demoTopEnforced,
        importFlows: demoImportFlows
    };
}

function toggleLibraryDemoMode() {
    libraryDemoMode = !libraryDemoMode;
    const button = document.getElementById('library-demo-button');
    const badge = document.getElementById('library-demo-badge');
    
    if (libraryDemoMode) {
        currentLibraryData = generateLibraryDemoData();
        button.textContent = 'üìä Show Real Data';
        button.classList.add('active');
        badge.style.display = 'inline-block';
    } else {
        currentLibraryData = realLibraryData;
        button.textContent = 'üé® Show Demo Data';
        button.classList.remove('active');
        badge.style.display = 'none';
    }
    
    updateAllLibraryCharts();
}

function exportLibraryCSV() {
    window.location.href = '/cwa-stats-export-csv/library' + window.location.search;
}

// Initialize on page load
if (document.getElementById('growth-chart')) {
    initLibraryCharts();
}
</script>
